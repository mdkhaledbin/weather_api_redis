# Weather API

A small FastAPI-based weather API that fetches weather data from a 3rd-party provider (Visual Crossing by default), caches results in Redis, and exposes a simple endpoint for getting the current hour's weather for a city/location.

This project demonstrates working with 3rd-party APIs, environment variables, in-memory caching (Redis), and rate limiting.

This is solution of roadmap.sh project weather api : https://roadmap.sh/projects/weather-api-wrapper-service

## Features

- Fetches weather data from a configurable external API (default: Visual Crossing).
- Caches API responses in Redis (uses the user-supplied location string as the key).
- Returns the weather for the city's current hour (uses geolocation/timezone lookup).
- Simple built-in rate limiting to protect the endpoint.
- Health check endpoint at `/`.

## Tech stack

<div align="left">
	<img src="images/python.svg" alt="Python" width="160" style="margin-right:12px;" />
	<img src="images/fastapi.svg" alt="FastAPI" width="160" style="margin-right:12px;" />
	<img src="images/redis.svg" alt="Redis" width="160" style="margin-right:12px;" />
	<img src="images/docker.svg" alt="Docker" width="160" />
</div>

- Python 3.11+ (project pinned packages in `requirements.txt`)
- FastAPI
- Redis (async client via `redis.asyncio`)
- Geopy, timezonefinder, pytz for timezone lookup

## Repository structure

- `weather_app/` - main app code
  - `app.py` - FastAPI application, endpoints, Redis init, and integration glue
  - `city_time.py` - get current hour for a given city (geolocation/timezone fallback)
  - `hourly_weather.py` - helper that extracts hourly data from the 3rd-party response
  - `response_model.py` - pydantic models used by the API
  - `config.yml` - local configuration for Redis host/port/db
  - `.env.example` - example environment variables

## Requirements

Install the Python dependencies from `requirements.txt`:

```bash
python -m pip install -r requirements.txt
```

Note: this project was developed and tested on macOS. It should work on Linux as well.

## Environment variables

Create a `.env` file in the `weather_app/` folder (or set environment variables in your environment). You can copy the example:

```bash
cp weather_app/.env.example weather_app/.env
# Edit weather_app/.env and set your API_KEY
```

Required env vars (from `.env.example`):

- `API_KEY` - The API key for the 3rd-party weather service (e.g. Visual Crossing).
- `BASE_URL` - Base URL for the weather API. The `.env.example` uses Visual Crossing's timeline endpoint:
  `https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/`

## Configuration (Redis)

The Redis connection is read from `weather_app/config.yml`:

```yaml
server:
	redis:
		host: localhost
		port: 6379
		db: 0
```

You can run Redis locally using Docker:

```bash
# on macOS / Linux
docker run -p 6379:6379 --name weather-redis -d redis:7
```

Or install Redis locally via your package manager.

## Running the app

From the project root (where `weather_app` folder is), run uvicorn:

```bash
uvicorn weather_app.app:app --reload --host 0.0.0.0 --port 8000
```

The app exposes:

- `GET /` - health check (returns a JSON status/message)
- `GET /weather/{location}` - returns weather for the current hour for the given location

Example: open `http://127.0.0.1:8000/docs` to view the interactive API docs generated by FastAPI.

## Endpoint details and behavior

GET /weather/{location}

- Description: Returns hourly weather details matching the city's current hour.
- Rate limiting: The endpoint is protected using `fastapi-limiter` and is configured to allow 1 request per 10 seconds by default in code (`Depends(RateLimiter(times=1, seconds=10))`). Adjust as needed in code.
- Caching: Responses from the 3rd-party API are cached in Redis using the `location` string as the key.
  - Cache TTL: 86400 seconds (12 hours) â€” set in code when calling `r.set(location, json.dumps(response_data), ex=86400)`.
  - On cache hit, the API will parse the cached JSON and return the relevant hour's weather with `source: "cache"`.
  - On cache miss, the API calls the external service, caches the full response, and returns `source: "api"`.

### Example request

```bash
curl -i http://127.0.0.1:8000/weather/London
```

### Example response (success)

Response format follows `WeatherResponse` defined in `weather_app/response_model.py` and contains:

- `location` - the location string asked for
- `weather` - a `WeatherDetail` object for the matching hour (many fields are optional)
- `source` - `api` or `cache`

Example (simplified):

```json
{
  "location": "London",
  "weather": {
    "datetime": "14:00:00",
    "temp": 12.3,
    "humidity": 77,
    "conditions": "Partially cloudy"
    // ...other fields...
  },
  "source": "api"
}
```

### Error responses

- If the city/time cannot be determined, the API returns an error describing the issue (HTTP 404 from the `city_time` helper converted to an `ErrorResponse`).
- If the external API fails, the API returns an `ErrorResponse` with a message.

## How caching works (implementation notes)

- On startup, the app creates an async Redis client using `redis.from_url()` with the host/port/db values from `config.yml` and initializes the `FastAPILimiter` with the same Redis instance.
- When querying `/weather/{location}`:
  1.  The app determines the city's current hour using `city_time.get_city_time()` (geopy and timezonefinder are used; a worldtimeapi fallback is present).
  2.  The app tries to read `await r.get(location)` from Redis.
  3.  If cached JSON is found, it is parsed and `get_weather_for_hour()` extracts the relevant hourly item.
  4.  If not found, the app calls the external API at `BASE_URL + location + '/today'`, caches the JSON with TTL 86400 seconds, and extracts the hour.

## Rate limiting

- Rate limiting is implemented via `fastapi-limiter` and relies on the same Redis instance used for caching. The code currently limits to 1 call per 10 seconds for `/weather/{location}`.

## Troubleshooting

- Redis connection errors:

  - Ensure Redis is running and `config.yml` points at the correct host/port/db.
  - If using Docker, confirm the container is running: `docker ps`.
  - Verify the app logs at startup show `Connected to Redis successfully`.

- Missing `API_KEY` or `BASE_URL`:

  - Ensure `weather_app/.env` exists and includes `API_KEY` and `BASE_URL` (or set them as environment variables).

- Hitting rate limits when testing:
  - The endpoint is purposely rate-limited. Increase or remove the `Depends(RateLimiter(...))` line in `weather_app/app.py` for local testing.

## Development notes & extending the project

- Improve error handling: make HTTP status codes consistent (use proper status codes for various errors and exceptions).
- Add tests: simple unit tests for `get_weather_for_hour()` and `get_city_time()` would be helpful.
- Add configurable cache TTL and rate limit via environment variables or `config.yml`.

## Contributing

PRs welcome. Please open an issue first if you'd like to discuss larger changes.

## License

This repository currently has no explicit license. Add a `LICENSE` file if you want to make reuse terms explicit.

## Quick start summary

1. Copy `.env.example` to `weather_app/.env` and set your `API_KEY`.
2. Start Redis (e.g., `docker run -p 6379:6379 --name weather-redis -d redis:7`).
3. Install dependencies: `python -m pip install -r requirements.txt`.
4. Run the server: `uvicorn weather_app.app:app --reload --host 0.0.0.0 --port 8000`.
